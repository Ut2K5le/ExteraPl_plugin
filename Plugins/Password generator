__id__ = "password_generator"
__name__ = "Password Generator"
__description__ = "Генерирует пароль по командам .password или .pass"
__author__ = "@Xarvyn & @ExteraPl"
__version__ = "1.0"
__icon__ = "Input_Key_by_EmojiRu_Bot/2"
__min_version__ = "11.12.0"

from base_plugin import BasePlugin, HookResult, HookStrategy
from ui.settings import Header, Switch
from markdown_utils import parse_markdown
from typing import Any
import string
import random
import traceback

try:
    from java.util import ArrayList
    _HAS_ARRAYLIST = True
except Exception:
    ArrayList = None
    _HAS_ARRAYLIST = False

class PasswordGeneratorPlugin(BasePlugin):
    def on_plugin_load(self):
        try:
            self.log("on_plugin_load: запуск плагина")
            self.add_on_send_message_hook()
            self.log("on_plugin_load: хук отправки сообщений зарегистрирован")
        except Exception:
            self.log("on_plugin_load: ошибка при загрузке плагина")
            self.log(traceback.format_exc())

    def on_plugin_unload(self):
        try:
            self.log("on_plugin_unload: выгрузка плагина")
        except Exception:
            self.log("on_plugin_unload: ошибка при выгрузке плагина")
            self.log(traceback.format_exc())

    def create_settings(self) -> list:
        try:
            self.log("create_settings: формирование настроек")
            settings = [
                Header(text="Настройки генератора паролей"),
                Switch(key="use_letters", text="Использовать буквы", default=True),
                Switch(key="use_numbers", text="Использовать числа", default=True),
                Switch(key="use_special", text="Использовать спец. символы", default=False),
                Header(text="Доп. функции"),
                Switch(key="prefix_password", text='Добовлять в начало "Password"', default=False)
            ]
            self.log(f"create_settings: настройки сформированы ({len(settings)} элементов)")
            return settings
        except Exception:
            self.log("create_settings: ошибка при формировании настроек")
            self.log(traceback.format_exc())
            return []

    def _to_java_arraylist(self, py_list):
        try:
            if not _HAS_ARRAYLIST:
                self.log("_to_java_arraylist: ArrayList недоступен в окружении")
                return None
            java_list = ArrayList()
            for i, item in enumerate(py_list):
                try:
                    java_list.add(item)
                    self.log(f"_to_java_arraylist: добавлен элемент {i}")
                except Exception:
                    self.log(f"_to_java_arraylist: ошибка при добавлении элемента {i}")
                    self.log(traceback.format_exc())
            try:
                size = java_list.size()
            except Exception:
                size = -1
            self.log(f"_to_java_arraylist: массив Java сформирован (size={size})")
            return java_list
        except Exception:
            self.log("_to_java_arraylist: неожиданная ошибка при создании ArrayList")
            self.log(traceback.format_exc())
            return None

    def on_send_message_hook(self, account: int, params: Any) -> HookResult:
        try:
            self.log("on_send_message_hook: вызван обработчик отправки сообщения")
            if not (hasattr(params, "message") or isinstance(params, dict)):
                self.log("on_send_message_hook: неверный params (нет поля message и не dict) -> DEFAULT")
                return HookResult(strategy=HookStrategy.DEFAULT)
            msg = ""
            if hasattr(params, "message"):
                try:
                    msg = params.message.strip()
                except Exception:
                    self.log("on_send_message_hook: не удалось получить params.message через атрибут")
                    self.log(traceback.format_exc())
                    msg = ""
            else:
                try:
                    msg = (params.get("message", "") or "").strip()
                except Exception:
                    self.log("on_send_message_hook: не удалось получить params['message']")
                    self.log(traceback.format_exc())
                    msg = ""
            self.log(f"on_send_message_hook: получено сообщение: '{msg}'")
            parts = msg.split()
            if not parts:
                self.log("on_send_message_hook: пустое сообщение -> DEFAULT")
                return HookResult(strategy=HookStrategy.DEFAULT)
            cmd = parts[0].lower()
            if cmd not in (".password", ".pass"):
                self.log(f"on_send_message_hook: команда '{cmd}' не распознана -> DEFAULT")
                return HookResult(strategy=HookStrategy.DEFAULT)
            self.log(f"on_send_message_hook: распознана команда '{cmd}'")
            length = 12
            if len(parts) >= 2:
                try:
                    length = int(parts[1])
                    self.log(f"on_send_message_hook: длина из команды: {length}")
                except Exception:
                    self.log(f"on_send_message_hook: не удалось распарсить длину '{parts[1]}', используем дефолт {length}")
                    length = 12
            if length < 1:
                self.log(f"on_send_message_hook: длина <1 ({length}), исправляю на 1")
                length = 1
            try:
                use_letters = bool(self.get_setting("use_letters", True))
                use_numbers = bool(self.get_setting("use_numbers", True))
                use_special = bool(self.get_setting("use_special", False))
                prefix_enabled = bool(self.get_setting("prefix_password", False))
                self.log(f"on_send_message_hook: настройки: letters={use_letters}, numbers={use_numbers}, special={use_special}, prefix={prefix_enabled}")
            except Exception:
                self.log("on_send_message_hook: ошибка при чтении настроек, использую значения по умолчанию")
                self.log(traceback.format_exc())
                use_letters = True
                use_numbers = True
                use_special = False
                prefix_enabled = False
            charset = ""
            if use_letters:
                charset += string.ascii_letters
            if use_numbers:
                charset += string.digits
            if use_special:
                charset += string.punctuation
            self.log(f"on_send_message_hook: сформирован набор символов (размер {len(charset)})")
            if not charset:
                self.log("on_send_message_hook: charset пустой -> CANCEL (нет выбранных символов)")
                return HookResult(strategy=HookStrategy.CANCEL)
            rnd = random.SystemRandom()
            try:
                password = "".join(rnd.choice(charset) for _ in range(length))
                self.log(f"on_send_message_hook: сгенерирован пароль: '{password}'")
            except Exception:
                self.log("on_send_message_hook: ошибка при генерации пароля")
                self.log(traceback.format_exc())
                return HookResult(strategy=HookStrategy.CANCEL)
            if prefix_enabled:
                markdown_str = "Password: " + f"`{password}`"
                self.log(f"on_send_message_hook: формирую Markdown-строку: {markdown_str}")
                try:
                    parsed = parse_markdown(markdown_str)
                    text = parsed.text
                    entities_py = [raw_entity.to_tlrpc_object() for raw_entity in parsed.entities]
                    self.log(f"on_send_message_hook: parse_markdown успешен, получено {len(entities_py)} raw entities")
                except Exception:
                    text = "Password: " + password
                    entities_py = []
                    self.log("on_send_message_hook: parse_markdown завершился ошибкой, отправляю plain text")
                    self.log(traceback.format_exc())
                java_entities = None
                try:
                    java_entities = self._to_java_arraylist(entities_py)
                except Exception:
                    self.log("on_send_message_hook: ошибка при конвертации entities в ArrayList")
                    self.log(traceback.format_exc())
                    java_entities = None
                if isinstance(params, dict):
                    try:
                        params["message"] = text
                        if java_entities is not None:
                            params["entities"] = java_entities
                            self.log("on_send_message_hook: params (dict) модифицирован: message и java entities установлены")
                        else:
                            params["entities"] = []
                            self.log("on_send_message_hook: params (dict) модифицирован: message установлен, entities пустые")
                    except Exception:
                        self.log("on_send_message_hook: ошибка при установке params (dict) с префиксом")
                        self.log(traceback.format_exc())
                else:
                    try:
                        setattr(params, "message", text)
                        self.log("on_send_message_hook: params.message установлен (объект)")
                    except Exception:
                        self.log("on_send_message_hook: не удалось установить params.message (объект)")
                        self.log(traceback.format_exc())
                    if java_entities is not None:
                        try:
                            setattr(params, "entities", java_entities)
                            self.log("on_send_message_hook: params.entities установлен (java ArrayList)")
                        except Exception:
                            self.log("on_send_message_hook: не удалось установить params.entities (java ArrayList)")
                            self.log(traceback.format_exc())
                    else:
                        try:
                            if hasattr(params, "entities"):
                                setattr(params, "entities", [])
                                self.log("on_send_message_hook: params.entities очищен (объект) после неудачной конвертации")
                        except Exception:
                            self.log("on_send_message_hook: не удалось очистить params.entities (объект)")
                            self.log(traceback.format_exc())
            else:
                if isinstance(params, dict):
                    try:
                        params["message"] = password
                        params.pop("entities", None)
                        self.log("on_send_message_hook: params (dict) модифицирован: message установлен, entities удалены")
                    except Exception:
                        self.log("on_send_message_hook: ошибка при установке params (dict) без префикса")
                        self.log(traceback.format_exc())
                else:
                    try:
                        setattr(params, "message", password)
                        self.log("on_send_message_hook: params.message установлен (объект) без префикса")
                    except Exception:
                        self.log("on_send_message_hook: не удалось установить params.message (объект) без префикса")
                        self.log(traceback.format_exc())
                    try:
                        if hasattr(params, "entities"):
                            setattr(params, "entities", [])
                            self.log("on_send_message_hook: params.entities очищен (объект)")
                    except Exception:
                        self.log("on_send_message_hook: не удалось очистить params.entities (объект)")
                        self.log(traceback.format_exc())
            self.log("on_send_message_hook: возвращаю HookResult MODIFY с обновлёнными параметрами")
            return HookResult(strategy=HookStrategy.MODIFY, params=params)
        except Exception:
            self.log("on_send_message_hook: НЕОЖИДАННАЯ ОШИБКА в обработчике")
            self.log(traceback.format_exc())
            return HookResult(strategy=HookStrategy.DEFAULT)
